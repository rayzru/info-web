name: Deploy (Reusable)

on:
  workflow_call:
    inputs:
      environment:
        description: 'Deployment environment (Beta or Production)'
        required: true
        type: string
      pm2_app_name:
        description: 'PM2 application name'
        required: true
        type: string
    secrets:
      SSH_PRIVATE_KEY:
        required: true
      SSH_HOST:
        required: true
      SSH_USER:
        required: true
      SSH_TARGET_DIR:
        required: true
      KNOWN_HOSTS:
        required: false
      # Auth
      AUTH_SECRET:
        required: true
      NEXTAUTH_SECRET:
        required: true
      NEXTAUTH_URL:
        required: true
      # OAuth
      YANDEX_CLIENT_ID:
        required: true
      YANDEX_CLIENT_SECRET:
        required: true
      VK_CLIENT_ID:
        required: true
      VK_CLIENT_SECRET:
        required: true
      GOOGLE_CLIENT_ID:
        required: true
      GOOGLE_CLIENT_SECRET:
        required: true
      # Database
      DATABASE_URL:
        required: true
      DATABASE_NAME:
        required: true
      # S3
      S3_URL:
        required: true
      S3_ACCESS_KEY:
        required: true
      S3_SECRET_KEY:
        required: true
      S3_BUCKET:
        required: true
      S3_REGION:
        required: true
      S3_PUBLIC_URL:
        required: true
      # SMTP
      SMTP_HOST:
        required: true
      SMTP_PORT:
        required: true
      SMTP_SECURE:
        required: true
      SMTP_USER:
        required: true
      SMTP_PASSWORD:
        required: true
      SMTP_FROM_NAME:
        required: true
      SMTP_FROM_EMAIL:
        required: true
      SMTP_REPLY_TO:
        required: true

concurrency:
  group: deploy-${{ inputs.environment }}
  cancel-in-progress: true

jobs:
  deploy:
    runs-on: ubuntu-latest
    environment: ${{ inputs.environment }}
    env:
      NODE_VERSION: "22"
      BUN_VERSION: "1.2.9"
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 1

      - uses: oven-sh/setup-bun@v1
        with:
          bun-version: ${{ env.BUN_VERSION }}

      - name: Install dependencies
        run: bun install --frozen-lockfile

      - name: Build (Next.js standalone)
        run: |
          # Clean cache to ensure fresh build
          echo "=== Cleaning Next.js cache ==="
          rm -rf .next/cache

          # Extract version from package.json and add environment suffix
          BUILD_VERSION=$(cat package.json | grep '"version"' | head -1 | awk -F: '{ print $2 }' | sed 's/[",]//g' | tr -d '[[:space:]]')
          if [ "${{ inputs.environment }}" = "Beta" ]; then
            BUILD_VERSION="${BUILD_VERSION}-beta"
          fi
          echo "=== Build version: $BUILD_VERSION ==="

          # Build with production settings
          echo "=== Building application ==="
          NEXT_PUBLIC_BUILD_VERSION=$BUILD_VERSION NODE_ENV=production bun run build

          # Capture BUILD_ID for verification
          BUILD_ID=$(cat .next/BUILD_ID)
          echo "=== Build ID: $BUILD_ID ==="
          echo "BUILD_ID=$BUILD_ID" >> $GITHUB_ENV

          # Prepare deployment directories
          mkdir -p deploy/standalone deploy/static deploy/public
          cp -r .next/standalone/* deploy/standalone/
          mkdir -p deploy/standalone/.next
          cp -r .next/static deploy/standalone/.next/
          cp -r .next/server deploy/standalone/.next/
          cp .next/BUILD_ID deploy/standalone/.next/
          cp .next/*.json deploy/standalone/.next/
          cp -r .next/static     deploy/static/
          [ -d public ] && [ -n "$(ls -A public 2>/dev/null)" ] && cp -r public/* deploy/public/ || echo "Public directory empty or doesn't exist"
          cp ecosystem.config.cjs deploy/standalone/
          cp -r drizzle deploy/standalone/
          cp drizzle.config.ts deploy/standalone/
          mkdir -p deploy/standalone/src/server/db
          cp src/server/db/schema.ts deploy/standalone/src/server/db/
          cp -r src/server/db/schemas deploy/standalone/src/server/db/
          cp src/server/db/migrate.ts deploy/standalone/src/server/db/
          cp package.json deploy/standalone/
          cp bun.lock deploy/standalone/

          # Verification
          echo "=== Deploy directory contents ==="
          ls -la deploy/standalone/ | head -15
          echo "=== .next directory check ==="
          ls -la deploy/standalone/.next/ || echo ".next directory not found in deploy"
          echo "=== BUILD_ID verification ==="
          cat deploy/standalone/.next/BUILD_ID
          echo "=== Static files check ==="
          ls -la deploy/static/ | head -10
          echo "=== Ecosystem config check ==="
          ls -la deploy/standalone/ecosystem.config.cjs || echo "Ecosystem config not found in deploy"
          echo "=== drizzle-kit check ==="
          ls -la deploy/standalone/node_modules/drizzle-kit || echo "drizzle-kit not found"
        env:
          SKIP_ENV_VALIDATION: "1"
          DATABASE_URL: "postgresql://placeholder"
          DATABASE_NAME: "placeholder"
          AUTH_SECRET: "placeholder-will-be-set-on-server"
          YANDEX_CLIENT_ID: "placeholder"
          YANDEX_CLIENT_SECRET: "placeholder"

      - name: Prepare SSH
        env:
          SSH_PRIVATE_KEY: ${{ secrets.SSH_PRIVATE_KEY }}
        run: |
          mkdir -p ~/.ssh

          # Add known hosts
          if [[ -n "${{ secrets.KNOWN_HOSTS }}" ]]; then
            echo "${{ secrets.KNOWN_HOSTS }}" >> ~/.ssh/known_hosts
          else
            echo "StrictHostKeyChecking no" >> ~/.ssh/config
            echo "UserKnownHostsFile /dev/null" >> ~/.ssh/config
          fi

          # Create SSH private key - use env var to preserve newlines
          echo "$SSH_PRIVATE_KEY" > ~/.ssh/id_ed25519

          # Ensure proper permissions and line endings
          chmod 600 ~/.ssh/id_ed25519
          [[ -f ~/.ssh/config ]] && chmod 600 ~/.ssh/config || true

          # Verify key format
          ssh-keygen -l -f ~/.ssh/id_ed25519 || echo "Warning: SSH key verification failed"

      - name: Upload release via rsync
        timeout-minutes: 15
        run: |
          set -euo pipefail

          # Validate required environment variables
          if [[ -z "$USER" || -z "$HOST" || -z "$TARGET" ]]; then
            echo "Error: Missing required SSH configuration"
            echo "USER: '$USER'"
            echo "HOST: '$HOST'"
            echo "TARGET: '$TARGET'"
            exit 1
          fi

          REL="releases/$(date -u +'%Y-%m-%dT%H-%M-%SZ')"
          echo "Creating release directory: $REL"

          # Test SSH connection
          echo "Testing SSH connection..."
          ssh -p 22 -o ConnectTimeout=30 "$USER@$HOST" "echo 'SSH connection successful' && uptime"

          # Create release directory structure that matches nginx expectations
          ssh -p 22 "$USER@$HOST" "mkdir -p $TARGET/$REL"

          # Deploy standalone app files to the root of the release (including .next directory)
          echo "Deploying standalone files..."
          timeout 300 rsync -azq --delete --exclude='.env' deploy/standalone/ "$USER@$HOST:$TARGET/$REL/" || echo "Standalone deployment failed or timed out"

          # Deploy static and public files to match nginx paths
          echo "Deploying static files..."
          timeout 180 rsync -azq --delete deploy/static/     "$USER@$HOST:$TARGET/$REL/static/" || echo "Static deployment failed or timed out"
          echo "Deploying public files..."
          timeout 60 rsync -azq deploy/public/     "$USER@$HOST:$TARGET/$REL/public/" || echo "Public deployment failed or timed out"

          # Create production .env file locally and upload
          echo "Creating production .env file..."
          cat > .env << EOF

          # Next Auth
          AUTH_SECRET="$AUTH_SECRET"
          NEXTAUTH_SECRET="$NEXTAUTH_SECRET"
          NEXTAUTH_URL="$NEXTAUTH_URL"

          # Yandex OAuth
          YANDEX_CLIENT_ID="$YANDEX_CLIENT_ID"
          YANDEX_CLIENT_SECRET="$YANDEX_CLIENT_SECRET"

          # VK OAuth
          VK_CLIENT_ID="$VK_CLIENT_ID"
          VK_CLIENT_SECRET="$VK_CLIENT_SECRET"

          # Google OAuth
          GOOGLE_CLIENT_ID="$GOOGLE_CLIENT_ID"
          GOOGLE_CLIENT_SECRET="$GOOGLE_CLIENT_SECRET"

          # Database (PostgreSQL)
          DATABASE_URL="$DATABASE_URL"
          DATABASE_NAME="$DATABASE_NAME"

          # S3 Storage
          S3_URL="$S3_URL"
          S3_ACCESS_KEY="$S3_ACCESS_KEY"
          S3_SECRET_KEY="$S3_SECRET_KEY"
          S3_BUCKET="$S3_BUCKET"
          S3_REGION="$S3_REGION"
          S3_PUBLIC_URL="$S3_PUBLIC_URL"

          # SMTP Configuration
          SMTP_HOST="$SMTP_HOST"
          SMTP_PORT="$SMTP_PORT"
          SMTP_SECURE="$SMTP_SECURE"
          SMTP_USER="$SMTP_USER"
          SMTP_PASSWORD="$SMTP_PASSWORD"
          SMTP_FROM_NAME="$SMTP_FROM_NAME"
          SMTP_FROM_EMAIL="$SMTP_FROM_EMAIL"
          SMTP_REPLY_TO="$SMTP_REPLY_TO"

          # Trust host for auth
          AUTH_TRUST_HOST=true
          EOF

          # Upload .env file to server
          scp .env "$USER@$HOST:$TARGET/$REL/.env"

          # Verify .env file was created and has content
          echo "Verifying .env file..."
          ssh "$USER@$HOST" "ls -la $TARGET/$REL/.env && echo 'File size:' && wc -c $TARGET/$REL/.env"

          # Verify BUILD_ID on server
          echo "=== Verifying BUILD_ID on server ==="
          ssh "$USER@$HOST" "cat $TARGET/$REL/.next/BUILD_ID"
        env:
          USER: ${{ secrets.SSH_USER }}
          HOST: ${{ secrets.SSH_HOST }}
          TARGET: ${{ secrets.SSH_TARGET_DIR }}
          # Environment variables for .env file creation
          AUTH_SECRET: ${{ secrets.AUTH_SECRET }}
          NEXTAUTH_SECRET: ${{ secrets.NEXTAUTH_SECRET }}
          NEXTAUTH_URL: ${{ secrets.NEXTAUTH_URL }}
          YANDEX_CLIENT_ID: ${{ secrets.YANDEX_CLIENT_ID }}
          YANDEX_CLIENT_SECRET: ${{ secrets.YANDEX_CLIENT_SECRET }}
          VK_CLIENT_ID: ${{ secrets.VK_CLIENT_ID }}
          VK_CLIENT_SECRET: ${{ secrets.VK_CLIENT_SECRET }}
          GOOGLE_CLIENT_ID: ${{ secrets.GOOGLE_CLIENT_ID }}
          GOOGLE_CLIENT_SECRET: ${{ secrets.GOOGLE_CLIENT_SECRET }}
          DATABASE_URL: ${{ secrets.DATABASE_URL }}
          DATABASE_NAME: ${{ secrets.DATABASE_NAME }}
          S3_URL: ${{ secrets.S3_URL }}
          S3_ACCESS_KEY: ${{ secrets.S3_ACCESS_KEY }}
          S3_SECRET_KEY: ${{ secrets.S3_SECRET_KEY }}
          S3_BUCKET: ${{ secrets.S3_BUCKET }}
          S3_REGION: ${{ secrets.S3_REGION }}
          S3_PUBLIC_URL: ${{ secrets.S3_PUBLIC_URL }}
          SMTP_HOST: ${{ secrets.SMTP_HOST }}
          SMTP_PORT: ${{ secrets.SMTP_PORT }}
          SMTP_SECURE: ${{ secrets.SMTP_SECURE }}
          SMTP_USER: ${{ secrets.SMTP_USER }}
          SMTP_PASSWORD: ${{ secrets.SMTP_PASSWORD }}
          SMTP_FROM_NAME: ${{ secrets.SMTP_FROM_NAME }}
          SMTP_FROM_EMAIL: ${{ secrets.SMTP_FROM_EMAIL }}
          SMTP_REPLY_TO: ${{ secrets.SMTP_REPLY_TO }}

      - name: Run database migrations
        timeout-minutes: 5
        run: |
          echo "=== Running database migrations ==="

          # Execute migration on server (all commands run remotely)
          # Use programmatic migration script instead of drizzle-kit to avoid TS path alias issues
          # The script uses drizzle-orm's migrate() function to apply SQL files from drizzle/ directory
          # Note: Server has bun 1.1.45, delete incompatible lockfile before install
          # Install all deps (not --production) to include drizzle-orm, postgres, etc.
          if ! ssh "$USER@$HOST" "cd $TARGET/releases && REL=\$(ls -1t | head -1) && echo \"Running migrations on release: \$REL\" && cd \$REL && rm -f bun.lock && bun install && bash -c 'set -a && source .env && set +a && bun run src/server/db/migrate.ts'"; then
            echo "âŒ Migration failed - deployment aborted"
            exit 1
          fi

          echo "âœ… Migrations completed successfully"
        env:
          USER: ${{ secrets.SSH_USER }}
          HOST: ${{ secrets.SSH_HOST }}
          TARGET: ${{ secrets.SSH_TARGET_DIR }}

      - name: Update symlink to current release (atomic)
        timeout-minutes: 2
        run: |
          echo "=== Updating symlink to current release (atomic swap) ==="
          ssh "$USER@$HOST" "cd $TARGET && ln -sfn releases/\$(ls -1t releases | head -1) current-new && mv -Tf current-new current && ls -la current"
          echo "âœ… Symlink updated atomically"
        env:
          USER: ${{ secrets.SSH_USER }}
          HOST: ${{ secrets.SSH_HOST }}
          TARGET: ${{ secrets.SSH_TARGET_DIR }}

      - name: Restart application (PM2)
        timeout-minutes: 3
        run: |
          PM2_APP_NAME="${{ inputs.pm2_app_name }}"
          echo "=== Restarting PM2 app: $PM2_APP_NAME ==="
          ssh "$USER@$HOST" "cd $TARGET/current && (pm2 delete $PM2_APP_NAME 2>/dev/null || true) && PM2_APP_NAME=$PM2_APP_NAME pm2 start ecosystem.config.cjs && pm2 save"
          echo "âœ… Application restarted successfully"
        env:
          USER: ${{ secrets.SSH_USER }}
          HOST: ${{ secrets.SSH_HOST }}
          TARGET: ${{ secrets.SSH_TARGET_DIR }}

      - name: Setup shared directories
        run: |
          echo "=== Setting up shared directories ==="
          ssh "$USER@$HOST" "
            mkdir -p $TARGET/shared/uploads/avatars
            rm -rf $TARGET/current/public/uploads
            ln -sfn $TARGET/shared/uploads $TARGET/current/public/uploads
            chown -R rayz:fastsecure $TARGET/shared/
            chmod -R 755 $TARGET/shared/
            ls -la $TARGET/current/public/ | grep uploads
          "
        env:
          USER: ${{ secrets.SSH_USER }}
          HOST: ${{ secrets.SSH_HOST }}
          TARGET: ${{ secrets.SSH_TARGET_DIR }}

      - name: Prune old releases (keep 5)
        run: |
          # Validate required environment variables
          if [[ -z "$USER" || -z "$HOST" || -z "$TARGET" ]]; then
            echo "Error: Missing required SSH configuration for cleanup"
            exit 1
          fi

          echo "=== Pruning old releases (keep 5) ==="
          ssh "$USER@$HOST" "bash -s $TARGET" << 'ENDSSH'
          set -euo pipefail
          KEEP_COUNT=5
          TARGET="$1"
          cd "$TARGET/releases" || exit 1

          # Count total releases
          TOTAL=$(ls -1 | wc -l)
          echo "ðŸ“¦ Total releases: $TOTAL"

          # List all releases
          echo ""
          echo "ðŸ“‹ Current releases (newest first):"
          ls -1t | nl -w2 -s'. '
          echo ""

          # Calculate deletions
          TO_DELETE=$((TOTAL - KEEP_COUNT))
          if [ "$TO_DELETE" -le 0 ]; then
            echo "âœ… No cleanup needed (keeping $KEEP_COUNT)"
            exit 0
          fi

          # Show what will be deleted
          echo "ðŸ—‘ï¸  Deleting $TO_DELETE oldest release(s):"
          ls -1t | tail -n +$((KEEP_COUNT + 1)) | while read dir; do
            echo "   - $dir"
          done
          echo ""

          # Delete old releases
          DELETED=0
          for dir in $(ls -1t | tail -n +$((KEEP_COUNT + 1))); do
            rm -rf "$dir" && DELETED=$((DELETED + 1))
          done

          # Verify
          REMAINING=$(ls -1 | wc -l)
          echo "âœ… Cleanup complete: deleted $DELETED, remaining $REMAINING"
          echo ""
          echo "ðŸ“‹ Remaining releases:"
          ls -1t | nl -w2 -s'. '
          ENDSSH
        env:
          USER: ${{ secrets.SSH_USER }}
          HOST: ${{ secrets.SSH_HOST }}
          TARGET: ${{ secrets.SSH_TARGET_DIR }}
